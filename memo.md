### main
* 入力(文字列) + 生成規則(EBNF) -> 構文木 -> 関数、処理へのマッピング -> 出力(整数)
  * 入力(配列)を構文木にするためにリンクリストにする
  * 構文木にするのは優先順位をつけて値を参照したいから
  * 重要なのはロジック全体を木構造で表現できてしまっているということ

### step1 ~ step4
* なんでわざわざtoken型の連想配列にするのか
  * 空白を除いて一文字ずつ処理するだけなら文字列のままでも処理できそうなのに
### step5
  * 構文木
    * データ構造だけを表現していると思っていたが、関数呼び出しの流れも同時に表現している
  * *や/を*や/として解釈せずに+や-で表現すればスタックマシンは不要でraxだけで良くなるはず
  * exprとmulのfor(;;)で詰まる
    * 構文木のグラフそのものが関数定義とその中身を表現したもの
      * データ構造に則ったロジックができれば後はマッピングするだけ
  * gen()の最初で詰まる
    * 構文木 -> スタックマシンが腹落ちしていない
  * main()
    * pop rax -> retがわかっていない
    * raxにスタックの値を代入 -> retは関数の戻り値であるraxを返す
  
### step6
  * 


### その他
* なぜ構造体ではなく構造体のポインタを返すのか
  * 返り値を関数の引数に渡す場合は参照渡しのほうがメモリ食わなくて良くなるから
* 